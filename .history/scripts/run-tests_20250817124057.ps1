# üß™ Script de test automatis√© pour le G√©n√©rateur Firebase + Next.js 2025 (Windows)
# Usage: .\scripts\run-tests.ps1 [-Verbose] [-NoCleanup]

param(
    [switch]$Verbose,
    [switch]$NoCleanup
)

# Configuration
$ScriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$ProjectDir = Split-Path -Parent $ScriptDir
Set-Location $ProjectDir

# Variables globales
$VerbosePreference = if ($Verbose) { "Continue" } else { "SilentlyContinue" }
$Cleanup = -not $NoCleanup
$TestResults = @()
$TotalTests = 19
$PassedTests = 0
$FailedTests = 0
$StartTime = Get-Date

# Fonctions utilitaires
function Write-Header {
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Blue
    Write-Host "‚ïë                    üß™ PLAN DE TEST COMPLET                    ‚ïë" -ForegroundColor Blue
    Write-Host "‚ïë              G√©n√©rateur Firebase + Next.js 2025              ‚ïë" -ForegroundColor Blue
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Blue
    Write-Host ""
}

function Write-Test {
    param($TestId, $Description)
    Write-Host "üîÑ $TestId - $Description" -ForegroundColor Cyan
}

function Write-Success {
    param($TestId, $Message)
    Write-Host "‚úÖ $TestId - $Message" -ForegroundColor Green
    $script:PassedTests++
    $script:TestResults += "$TestId:SUCCESS"
}

function Write-Failure {
    param($TestId, $Message, $Error)
    Write-Host "‚ùå $TestId - $Message" -ForegroundColor Red
    if ($Error) {
        Write-Host "   Erreur: $Error" -ForegroundColor Red
    }
    $script:FailedTests++
    $script:TestResults += "$TestId:FAILURE:$Error"
}

function Write-Info {
    param($Message)
    Write-Host "‚ÑπÔ∏è  $Message" -ForegroundColor Blue
}

function Write-Warning {
    param($Message)
    Write-Host "‚ö†Ô∏è  $Message" -ForegroundColor Yellow
}

function Write-Step {
    param($Step)
    Write-Host "üìã $Step" -ForegroundColor Magenta
}

# Fonction de nettoyage
function Cleanup {
    Write-Step "Nettoyage des projets de test..."
    
    $TestProjects = @("test-output-minimal", "test-output-complete", "test-output")
    
    foreach ($Project in $TestProjects) {
        if (Test-Path $Project) {
            Remove-Item -Recurse -Force $Project
            Write-Info "Projet $Project supprim√©"
        }
    }
    
    # Nettoyer les fichiers temporaires
    $TempFiles = @("check-links.js", "test-report.txt")
    foreach ($File in $TempFiles) {
        if (Test-Path $File) {
            Remove-Item -Force $File
        }
    }
}

# Gestion des signaux pour le nettoyage
try {
    # V√©rification des pr√©requis
    function Check-Prerequisites {
        Write-Step "V√©rification des pr√©requis..."
        
        # V√©rifier Node.js
        try {
            $NodeVersion = node --version
            if ($NodeVersion -match "v1[89]\.|v2[0-9]\.|v3[0-9]\.") {
                Write-Success "PREREQ-001" "Node.js $NodeVersion OK"
            } else {
                Write-Failure "PREREQ-002" "Version Node.js incompatible" "Version $NodeVersion d√©tect√©e, 18+ requis"
                exit 1
            }
        } catch {
            Write-Failure "PREREQ-001" "Node.js non install√©" "Commande 'node' non trouv√©e"
            exit 1
        }
        
        # V√©rifier npm
        try {
            $NpmVersion = npm --version
            if ($NpmVersion -match "^[9-9]\.|^[1-9][0-9]\.") {
                Write-Success "PREREQ-002" "npm $NpmVersion OK"
            } else {
                Write-Failure "PREREQ-004" "Version npm incompatible" "Version $NpmVersion d√©tect√©e, 9+ requis"
                exit 1
            }
        } catch {
            Write-Failure "PREREQ-003" "npm non install√©" "Commande 'npm' non trouv√©e"
            exit 1
        }
        
        # V√©rifier Git
        try {
            $GitVersion = git --version
            Write-Success "PREREQ-003" "Git OK"
        } catch {
            Write-Failure "PREREQ-005" "Git non install√©" "Commande 'git' non trouv√©e"
            exit 1
        }
        
        # V√©rifier Firebase CLI (optionnel)
        try {
            $FirebaseVersion = firebase --version
            Write-Success "PREREQ-004" "Firebase CLI $FirebaseVersion OK"
        } catch {
            Write-Warning "Firebase CLI non install√© (optionnel pour les tests)"
        }
    }

    # Test 001: V√©rification de l'environnement de base
    function Test-001 {
        $TestId = "TEST-001"
        Write-Test $TestId "V√©rification de l'environnement de base"
        
        # V√©rifications d√©j√† faites dans Check-Prerequisites
        Write-Success $TestId "Environnement de base v√©rifi√©"
    }

    # Test 002: Installation des d√©pendances du g√©n√©rateur
    function Test-002 {
        $TestId = "TEST-002"
        Write-Test $TestId "Installation des d√©pendances du g√©n√©rateur"
        
        if (-not (Test-Path "package.json")) {
            Write-Failure $TestId "package.json non trouv√©" "Fichier package.json manquant"
            return $false
        }
        
        Write-Info "Installation des d√©pendances..."
        try {
            npm install --silent
            Write-Success $TestId "D√©pendances install√©es avec succ√®s"
            return $true
        } catch {
            Write-Failure $TestId "√âchec de l'installation des d√©pendances" "npm install a √©chou√©"
            return $false
        }
    }

    # Test 003: Build du g√©n√©rateur
    function Test-003 {
        $TestId = "TEST-003"
        Write-Test $TestId "Build du g√©n√©rateur"
        
        Write-Info "Build de production..."
        try {
            npm run build --silent
            if (Test-Path "dist") {
                Write-Success $TestId "Build r√©ussi, dossier dist/ cr√©√©"
                return $true
            } else {
                Write-Failure $TestId "Dossier dist/ manquant apr√®s build" "Build termin√© mais dist/ non cr√©√©"
                return $false
            }
        } catch {
            Write-Failure $TestId "√âchec du build" "npm run build a √©chou√©"
            return $false
        }
    }

    # Test 004: V√©rification de la CLI
    function Test-004 {
        $TestId = "TEST-004"
        Write-Test $TestId "V√©rification de la CLI"
        
        # Tester la commande d'aide
        try {
            $null = npx ts-node src/cli.ts --help 2>$null
            Write-Success $TestId "CLI fonctionnelle, commande d'aide OK"
            return $true
        } catch {
            Write-Failure $TestId "CLI d√©faillante" "Commande d'aide √©chou√©e"
            return $false
        }
    }

    # Test 005: G√©n√©ration d'un projet minimal
    function Test-005 {
        $TestId = "TEST-005"
        Write-Test $TestId "G√©n√©ration d'un projet minimal"
        
        Write-Info "Cr√©ation du projet minimal..."
        
        try {
            # Cr√©er le projet avec des options non-interactives
            $null = npx ts-node src/cli.ts create `
                --name test-minimal `
                --description "Projet de test minimal" `
                --author "Test User" `
                --version "1.0.0" `
                --package-manager npm `
                --nextjs-version 15 `
                --ui mui `
                --state-management zustand `
                --features pwa `
                --output ./test-output-minimal `
                --non-interactive
            
            if (Test-Path "test-output-minimal") {
                Write-Success $TestId "Projet minimal cr√©√© avec succ√®s"
                return $true
            } else {
                Write-Failure $TestId "Dossier de sortie non cr√©√©" "test-output-minimal manquant"
                return $false
            }
        } catch {
            Write-Failure $TestId "√âchec de la g√©n√©ration" "Commande de g√©n√©ration √©chou√©e"
            return $false
        }
    }

    # Test 006: V√©rification de la structure du projet minimal
    function Test-006 {
        $TestId = "TEST-006"
        Write-Test $TestId "V√©rification de la structure du projet minimal"
        
        $ProjectDir = "test-output-minimal"
        
        # V√©rifier les dossiers principaux
        $RequiredDirs = @("frontend", "backend", "scripts")
        foreach ($Dir in $RequiredDirs) {
            if (-not (Test-Path "$ProjectDir/$Dir")) {
                Write-Failure $TestId "Dossier $Dir manquant" "Structure du projet incompl√®te"
                return $false
            }
        }
        
        # V√©rifier les fichiers principaux
        $RequiredFiles = @("README.md", "frontend/package.json", "backend/firebase.json")
        foreach ($File in $RequiredFiles) {
            if (-not (Test-Path "$ProjectDir/$File")) {
                Write-Failure $TestId "Fichier $File manquant" "Structure du projet incompl√®te"
                return $false
            }
        }
        
        Write-Success $TestId "Structure du projet minimal correcte"
        return $true
    }

    # Test 007: V√©rification des fichiers frontend
    function Test-007 {
        $TestId = "TEST-007"
        Write-Test $TestId "V√©rification des fichiers frontend"
        
        $FrontendDir = "test-output-minimal/frontend"
        
        # V√©rifier la structure src/
        $RequiredSrcDirs = @("src/app", "src/components", "src/hooks", "src/stores", "src/lib")
        foreach ($Dir in $RequiredSrcDirs) {
            if (-not (Test-Path "$FrontendDir/$Dir")) {
                Write-Failure $TestId "Dossier $Dir manquant" "Structure frontend incompl√®te"
                return $false
            }
        }
        
        # V√©rifier les fichiers cl√©s
        $RequiredFiles = @("src/app/page.tsx", "src/app/layout.tsx", "package.json")
        foreach ($File in $RequiredFiles) {
            if (-not (Test-Path "$FrontendDir/$File")) {
                Write-Failure $TestId "Fichier $File manquant" "Fichiers frontend incomplets"
                return $false
            }
        }
        
        # V√©rifier les d√©pendances MUI et Zustand
        $PackageContent = Get-Content "$FrontendDir/package.json" -Raw
        if ($PackageContent -match "mui" -and $PackageContent -match "zustand") {
            Write-Success $TestId "Fichiers frontend et d√©pendances corrects"
            return $true
        } else {
            Write-Failure $TestId "D√©pendances manquantes" "MUI ou Zustand non configur√©s"
            return $false
        }
    }

    # Test 008: V√©rification des fichiers backend
    function Test-008 {
        $TestId = "TEST-008"
        Write-Test $TestId "V√©rification des fichiers backend"
        
        $BackendDir = "test-output-minimal/backend"
        
        # V√©rifier les fichiers de configuration Firebase
        $RequiredFiles = @("firebase.json", ".firebaserc")
        foreach ($File in $RequiredFiles) {
            if (-not (Test-Path "$BackendDir/$File")) {
                Write-Failure $TestId "Fichier $File manquant" "Configuration Firebase incompl√®te"
                return $false
            }
        }
        
        # V√©rifier la structure functions/
        $RequiredDirs = @("functions", "firestore", "storage")
        foreach ($Dir in $RequiredDirs) {
            if (-not (Test-Path "$BackendDir/$Dir")) {
                Write-Failure $TestId "Dossier $Dir manquant" "Structure backend incompl√®te"
                return $false
            }
        }
        
        # V√©rifier les fichiers functions
        $RequiredFunctionFiles = @("functions/package.json", "functions/src/index.ts")
        foreach ($File in $RequiredFunctionFiles) {
            if (-not (Test-Path "$BackendDir/$File")) {
                Write-Failure $TestId "Fichier $File manquant" "Fonctions Firebase incompl√®tes"
                return $false
            }
        }
        
        Write-Success $TestId "Fichiers backend corrects"
        return $true
    }

    # Test 009: V√©rification des templates Handlebars
    function Test-009 {
        $TestId = "TEST-009"
        Write-Test $TestId "V√©rification des templates Handlebars"
        
        $ProjectDir = "test-output-minimal"
        
        # V√©rifier qu'aucune variable Handlebars n'est rest√©e non remplac√©e
        $UnprocessedVars = Get-ChildItem -Path $ProjectDir -Recurse -File | 
            Where-Object { $_.Extension -eq ".tsx" -or $_.Extension -eq ".ts" -or $_.Extension -eq ".json" -or $_.Extension -eq ".md" } |
            ForEach-Object { Get-Content $_.FullName -Raw } |
            Select-String "{{.*}}" -AllMatches |
            ForEach-Object { $_.Matches } |
            ForEach-Object { $_.Value }
        
        if ($UnprocessedVars) {
            Write-Failure $TestId "Variables Handlebars non remplac√©es" "Variables trouv√©es: $($UnprocessedVars -join ', ')"
            return $false
        }
        
        # V√©rifier que le nom du projet appara√Æt dans les fichiers
        $ProjectFiles = Get-ChildItem -Path $ProjectDir -Recurse -File |
            Where-Object { $_.Extension -eq ".tsx" -or $_.Extension -eq ".ts" -or $_.Extension -eq ".json" -or $_.Extension -eq ".md" }
        
        $FoundProjectName = $false
        foreach ($File in $ProjectFiles) {
            $Content = Get-Content $File.FullName -Raw
            if ($Content -match "test-minimal") {
                $FoundProjectName = $true
                break
            }
        }
        
        if ($FoundProjectName) {
            Write-Success $TestId "Templates Handlebars correctement trait√©s"
            return $true
        } else {
            Write-Failure $TestId "Nom du projet non trouv√©" "Variables non remplac√©es"
            return $false
        }
    }

    # Test 010: G√©n√©ration d'un projet complet
    function Test-010 {
        $TestId = "TEST-010"
        Write-Test $TestId "G√©n√©ration d'un projet complet"
        
        Write-Info "Cr√©ation du projet complet..."
        
        try {
            # Cr√©er le projet avec toutes les fonctionnalit√©s
            $null = npx ts-node src/cli.ts create `
                --name test-complete `
                --description "Projet de test complet" `
                --author "Test User" `
                --version "1.0.0" `
                --package-manager npm `
                --nextjs-version 15 `
                --ui shadcn `
                --state-management redux `
                --features pwa,fcm,analytics,performance,sentry `
                --output ./test-output-complete `
                --non-interactive
            
            if (Test-Path "test-output-complete") {
                Write-Success $TestId "Projet complet cr√©√© avec succ√®s"
                return $true
            } else {
                Write-Failure $TestId "Dossier de sortie non cr√©√©" "test-output-complete manquant"
                return $false
            }
        } catch {
            Write-Failure $TestId "√âchec de la g√©n√©ration" "Commande de g√©n√©ration √©chou√©e"
            return $false
        }
    }

    # Test 011: V√©rification des fonctionnalit√©s avanc√©es
    function Test-011 {
        $TestId = "TEST-011"
        Write-Test $TestId "V√©rification des fonctionnalit√©s avanc√©es"
        
        $ProjectDir = "test-output-complete"
        
        # V√©rifier PWA
        if (Test-Path "$ProjectDir/frontend/public/manifest.json") {
            Write-Info "‚úÖ PWA configur√©"
        } else {
            Write-Failure $TestId "PWA non configur√©" "manifest.json manquant"
            return $false
        }
        
        # V√©rifier FCM
        if (Test-Path "$ProjectDir/frontend/src/fcm/fcm-config.ts") {
            Write-Info "‚úÖ FCM configur√©"
        } else {
            Write-Failure $TestId "FCM non configur√©" "fcm-config.ts manquant"
            return $false
        }
        
        # V√©rifier Analytics
        if (Test-Path "$ProjectDir/frontend/src/lib/analytics-config.ts") {
            Write-Info "‚úÖ Analytics configur√©"
        } else {
            Write-Failure $TestId "Analytics non configur√©" "analytics-config.ts manquant"
            return $false
        }
        
        # V√©rifier Performance
        if (Test-Path "$ProjectDir/frontend/src/performance/performance-config.ts") {
            Write-Info "‚úÖ Performance configur√©"
        } else {
            Write-Failure $TestId "Performance non configur√©" "performance-config.ts manquant"
            return $false
        }
        
        # V√©rifier Sentry
        if (Test-Path "$ProjectDir/frontend/src/sentry/sentry-config.ts") {
            Write-Info "‚úÖ Sentry configur√©"
        } else {
            Write-Failure $TestId "Sentry non configur√©" "sentry-config.ts manquant"
            return $false
        }
        
        Write-Success $TestId "Toutes les fonctionnalit√©s avanc√©es configur√©es"
        return $true
    }

    # Test 012: V√©rification des composants Shadcn/ui
    function Test-012 {
        $TestId = "TEST-012"
        Write-Test $TestId "V√©rification des composants Shadcn/ui"
        
        $ProjectDir = "test-output-complete"
        
        # V√©rifier les composants Shadcn
        $RequiredComponents = @("Button.tsx", "Card.tsx")
        foreach ($Component in $RequiredComponents) {
            if (-not (Test-Path "$ProjectDir/frontend/src/components/shadcn/$Component")) {
                Write-Failure $TestId "Composant $Component manquant" "Composants Shadcn incomplets"
                return $false
            }
        }
        
        # V√©rifier les composants UI
        $RequiredUiComponents = @("button.tsx", "card.tsx")
        foreach ($Component in $RequiredUiComponents) {
            if (-not (Test-Path "$ProjectDir/frontend/src/components/ui/$Component")) {
                Write-Failure $TestId "Composant UI $Component manquant" "Composants UI incomplets"
                return $false
            }
        }
        
        Write-Success $TestId "Composants Shadcn/ui correctement configur√©s"
        return $true
    }

    # Test 013: V√©rification de Redux Toolkit
    function Test-013 {
        $TestId = "TEST-013"
        Write-Test $TestId "V√©rification de Redux Toolkit"
        
        $ProjectDir = "test-output-complete"
        
        # V√©rifier les stores Redux
        if (-not (Test-Path "$ProjectDir/frontend/src/stores/redux/auth-slice.ts")) {
            Write-Failure $TestId "Store Redux manquant" "auth-slice.ts non trouv√©"
            return $false
        }
        
        # V√©rifier les d√©pendances Redux
        $PackageContent = Get-Content "$ProjectDir/frontend/package.json" -Raw
        if ($PackageContent -match "@reduxjs/toolkit" -and $PackageContent -match "react-redux") {
            Write-Success $TestId "Redux Toolkit correctement configur√©"
            return $true
        } else {
            Write-Failure $TestId "D√©pendances Redux manquantes" "@reduxjs/toolkit ou react-redux non configur√©s"
            return $false
        }
    }

    # Test 014: V√©rification de la navigation entre documents
    function Test-014 {
        $TestId = "TEST-014"
        Write-Test $TestId "V√©rification de la navigation entre documents"
        
        # V√©rifier que tous les fichiers de documentation existent
        $RequiredDocs = @("README.md", "NAVIGATION.md", "INSTALLATION.md", "USAGE.md", "DEPLOYMENT.md", "CUSTOMIZATION.md", "BEST_PRACTICES.md", "MAINTENANCE.md", "CONTRIBUTING.md", "EXAMPLES.md")
        
        foreach ($Doc in $RequiredDocs) {
            if (-not (Test-Path "docs/$Doc")) {
                Write-Failure $TestId "Document $Doc manquant" "Documentation incompl√®te"
                return $false
            }
        }
        
        Write-Success $TestId "Tous les documents de documentation pr√©sents"
        return $true
    }

    # Test 015: V√©rification de la coh√©rence des liens
    function Test-015 {
        $TestId = "TEST-015"
        Write-Test $TestId "V√©rification de la coh√©rence des liens"
        
        # Cr√©er un script de v√©rification des liens
        $CheckLinksScript = @"
const fs = require('fs');
const path = require('path');

function checkLinksInFile(filePath) {
    try {
        const content = fs.readFileSync(filePath, 'utf8');
        const linkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        const links = [];
        let match;
        
        while ((match = linkRegex.exec(content)) !== null) {
            links.push({
                text: match[1],
                url: match[2],
                file: filePath
            });
        }
        
        return links;
    } catch (error) {
        return [];
    }
}

function checkAllLinks() {
    const docsDir = './docs';
    const mdFiles = fs.readdirSync(docsDir).filter(f => f.endsWith('.md'));
    const allLinks = [];
    
    mdFiles.forEach(file => {
        const filePath = path.join(docsDir, file);
        const links = checkLinksInFile(filePath);
        allLinks.push(...links);
    });
    
    console.log('Liens trouv√©s:');
    allLinks.forEach(link => {
        console.log(\`- \${link.file}: [\${link.text}](\${link.url})\`);
    });
    
    return allLinks;
}

checkAllLinks();
"@
        
        $CheckLinksScript | Out-File -FilePath "check-links.js" -Encoding UTF8
        
        # Ex√©cuter la v√©rification
        try {
            $null = node check-links.js 2>$null
            Write-Success $TestId "Liens de documentation v√©rifi√©s"
            return $true
        } catch {
            Write-Failure $TestId "Erreur lors de la v√©rification des liens" "Script de v√©rification √©chou√©"
            return $false
        }
    }

    # Test 016: V√©rification de la structure de la documentation
    function Test-016 {
        $TestId = "TEST-016"
        Write-Test $TestId "V√©rification de la structure de la documentation"
        
        # V√©rifier la structure des documents principaux
        $ReadmeSections = (Get-Content "docs/README.md" | Select-String "^## ").Count
        $NavigationSections = (Get-Content "docs/NAVIGATION.md" | Select-String "^## ").Count
        $InstallationSections = (Get-Content "docs/INSTALLATION.md" | Select-String "^## ").Count
        
        if ($ReadmeSections -ge 5 -and $NavigationSections -ge 5 -and $InstallationSections -ge 5) {
            Write-Success $TestId "Structure de la documentation conforme"
            return $true
        } else {
            Write-Failure $TestId "Structure de documentation insuffisante" "Sections manquantes dans les documents"
            return $false
        }
    }

    # Test 017: Validation des projets g√©n√©r√©s
    function Test-017 {
        $TestId = "TEST-017"
        Write-Test $TestId "Validation des projets g√©n√©r√©s"
        
        # V√©rifier la validit√© des package.json
        $Projects = @("test-output-minimal", "test-output-complete")
        
        foreach ($Project in $Projects) {
            if (Test-Path $Project) {
                $PackageJson = "$Project/frontend/package.json"
                if (Test-Path $PackageJson) {
                    try {
                        $null = Get-Content $PackageJson | ConvertFrom-Json
                        Write-Info "‚úÖ $Project : package.json valide"
                    } catch {
                        Write-Failure $TestId "package.json invalide dans $Project" "JSON malform√©"
                        return $false
                    }
                }
            }
        }
        
        Write-Success $TestId "Projets g√©n√©r√©s valid√©s"
        return $true
    }

    # Test 018: Nettoyage des projets de test
    function Test-018 {
        $TestId = "TEST-018"
        Write-Test $TestId "Nettoyage des projets de test"
        
        # Nettoyer les projets de test
        $Projects = @("test-output-minimal", "test-output-complete", "test-output")
        
        foreach ($Project in $Projects) {
            if (Test-Path $Project) {
                Remove-Item -Recurse -Force $Project
                Write-Info "‚úÖ $Project supprim√©"
            }
        }
        
        # Nettoyer les fichiers temporaires
        $TempFiles = @("check-links.js", "test-report.txt")
        foreach ($File in $TempFiles) {
            if (Test-Path $File) {
                Remove-Item -Force $File
            }
        }
        
        Write-Success $TestId "Nettoyage des projets de test r√©ussi"
        return $true
    }

    # Test 019: V√©rification finale de l'environnement
    function Test-019 {
        $TestId = "TEST-019"
        Write-Test $TestId "V√©rification finale de l'environnement"
        
        # V√©rifier que nous sommes dans le bon r√©pertoire
        if ((Get-Location).Path -eq $ProjectDir) {
            Write-Info "‚úÖ R√©pertoire correct: $((Get-Location).Path)"
        } else {
            Write-Failure $TestId "R√©pertoire incorrect" "R√©pertoire actuel: $((Get-Location).Path)"
            return $false
        }
        
        # V√©rifier que le g√©n√©rateur fonctionne toujours
        try {
            $null = npx ts-node src/cli.ts --version 2>$null
            Write-Success $TestId "Environnement final v√©rifi√©, g√©n√©rateur fonctionnel"
            return $true
        } catch {
            Write-Failure $TestId "G√©n√©rateur d√©faillant apr√®s les tests" "CLI non fonctionnelle"
            return $false
        }
    }

    # Fonction principale d'ex√©cution des tests
    function Run-AllTests {
        Write-Header
        
        Write-Info "üöÄ D√©marrage des tests automatis√©s..."
        Write-Info "üìÅ R√©pertoire de travail: $ProjectDir"
        Write-Info "‚è∞ Heure de d√©but: $(Get-Date)"
        Write-Host ""
        
        # V√©rification des pr√©requis
        Check-Prerequisites
        Write-Host ""
        
        # Ex√©cution des tests
        $Tests = @(
            "Test-001",
            "Test-002",
            "Test-003",
            "Test-004",
            "Test-005",
            "Test-006",
            "Test-007",
            "Test-008",
            "Test-009",
            "Test-010",
            "Test-011",
            "Test-012",
            "Test-013",
            "Test-014",
            "Test-015",
            "Test-016",
            "Test-017",
            "Test-018",
            "Test-019"
        )
        
        foreach ($Test in $Tests) {
            if (& $Test) {
                Write-Info "‚úÖ $Test r√©ussi"
            } else {
                Write-Warning "‚ö†Ô∏è  $Test √©chou√©, continuation des autres tests..."
            }
            Write-Host ""
        }
    }

    # G√©n√©ration du rapport final
    function Generate-Report {
        $EndTime = Get-Date
        $Duration = ($EndTime - $StartTime).TotalSeconds
        
        Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Blue
        Write-Host "‚ïë                        üìä RAPPORT FINAL                      ‚ïë" -ForegroundColor Blue
        Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Blue
        Write-Host ""
        
        Write-Host "üìà R√©sultats des tests:" -ForegroundColor Cyan
        Write-Host "   Total: $TotalTests"
        Write-Host "   ‚úÖ R√©ussis: $PassedTests"
        Write-Host "   ‚ùå √âchou√©s: $FailedTests"
        Write-Host "   ‚è±Ô∏è  Dur√©e: $([math]::Round($Duration, 2))s"
        Write-Host ""
        
        # Calculer le pourcentage de r√©ussite
        $SuccessRate = [math]::Round(($PassedTests * 100) / $TotalTests)
        Write-Host "üìä Taux de r√©ussite: ${SuccessRate}%" -ForegroundColor Cyan
        Write-Host ""
        
        if ($SuccessRate -eq 100) {
            Write-Host "üéâ Tous les tests ont r√©ussi !" -ForegroundColor Green
            Write-Host "üöÄ Le g√©n√©rateur est pr√™t pour la production !" -ForegroundColor Green
        } elseif ($SuccessRate -ge 80) {
            Write-Host "‚ö†Ô∏è  La plupart des tests ont r√©ussi." -ForegroundColor Yellow
            Write-Host "üîß Quelques ajustements mineurs peuvent √™tre n√©cessaires." -ForegroundColor Yellow
        } else {
            Write-Host "‚ùå Trop de tests ont √©chou√©." -ForegroundColor Red
            Write-Host "üö® Une r√©vision majeure est n√©cessaire." -ForegroundColor Red
        }
        Write-Host ""
        
        # Afficher les d√©tails des √©checs
        if ($FailedTests -gt 0) {
            Write-Host "‚ùå Tests √©chou√©s:" -ForegroundColor Red
            foreach ($Result in $TestResults) {
                if ($Result -match ":FAILURE:") {
                    $TestId = $Result.Split(":")[0]
                    $Error = $Result.Split(":", 3)[2]
                    Write-Host "   $TestId : $Error"
                }
            }
            Write-Host ""
        }
        
        # Sauvegarder le rapport
        $ReportContent = @"
RAPPORT DE TEST - $(Get-Date)
========================
Total: $TotalTests
R√©ussis: $PassedTests
√âchou√©s: $FailedTests
Taux de r√©ussite: ${SuccessRate}%
Dur√©e: $([math]::Round($Duration, 2))s

D√©tails des √©checs:
"@
        
        foreach ($Result in $TestResults) {
            if ($Result -match ":FAILURE:") {
                $ReportContent += "`n$Result"
            }
        }
        
        $ReportContent | Out-File -FilePath "test-report.txt" -Encoding UTF8
        
        Write-Info "üìÑ Rapport sauvegard√© dans test-report.txt"
    }

    # Ex√©cution principale
    function Main {
        # Nettoyage initial
        Cleanup
        
        # Ex√©cution des tests
        Run-AllTests
        
        # G√©n√©ration du rapport
        Generate-Report
        
        # Nettoyage final si activ√©
        if ($Cleanup) {
            Cleanup
        }
        
        # Code de sortie bas√© sur le succ√®s
        if ($FailedTests -eq 0) {
            exit 0
        } else {
            exit 1
        }
    }

    # Ex√©cution du script principal
    Main

} finally {
    # Nettoyage en cas d'erreur
    if ($Cleanup) {
        Cleanup
    }
} 